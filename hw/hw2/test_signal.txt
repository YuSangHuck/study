#include <pthread.h>
#include <sys/wait.h>
#include <string.h>
#include <stdlib.h>
#include <unistd.h>
#include <stdio.h>
#include <signal.h>

/*
 * 시그널 핸들러
 * 핸들러가 호출된 쓰레드의 ID와 시그널 번호를 출력한다.
 */
void sig_handler(int signo)
{
    printf("SIGNAL RECV TH ID %d : %d\n", pthread_self(),signo);
}

void *threadfunc2(void *arg);
void *threadfunc(void *arg);
void *s_signal(void *arg);

// 쓰레드 ID를 저장한다.  
int sigid[2];

int main()
{
    int n, i, j;
    pthread_t threadid;

    // 원하는 쓰레드로 시그널이 전달하는지 확인하기 위해서
    // 쓰레드 ID를 확인한다.
    if ((n = pthread_create(&threadid, NULL, threadfunc2, NULL)) != 0 )
    {
        perror("Thread create error ");
        exit(0);
    }
    sigid[0] = threadid;
    printf("thread2 id %d\n", threadid);

    if ((n = pthread_create(&threadid, NULL, threadfunc, NULL)) != 0 )
    {
        perror("Thread create error ");
        exit(0);
    }
    sigid[1] = threadid;
    printf("thread id %d\n", threadid);

    if ((n = pthread_create(&threadid, NULL, s_signal, NULL)) != 0 )
    {
        perror("Thread create error ");
        exit(0);
    }

    pthread_join(threadid, NULL);
}

void *threadfunc(void *arg)
{
    int i=0, j;
    struct sigaction act;
    sigset_t newmask;

    // 결과의 확인을 위해서 쓰레드 ID를 출력한다.
    printf("SIGINT Thread Start (%d)\n", pthread_self());

    // SIGINT에 대해서 시그널 핸들러를 등록했지만 
    // SIGINT를 블럭하도록 했으므로 시그널은 전달되지 않는다.  
    sigemptyset(&newmask);
    sigaddset(&newmask, SIGINT);
    act.sa_handler = sig_handler;
    sigaction(SIGINT, &act, NULL);
    pthread_sigmask(SIG_BLOCK, &newmask, NULL);	

    while(1)
    {
        printf("%d\n", i);
        i++;
        sleep(1);
    }
    return ;
}

void *threadfunc2(void *arg)
{
    struct sigaction act;
	int lsigno;

    sigset_t newmask;
    sigemptyset(&newmask);
    sigaddset(&newmask, SIGINT);

	// 시그널 핸들러를 등록 시켰지만 
	// sigwiat()가 가디리고 있으므로 실행되지 않는다.  
    act.sa_handler = sig_handler;
    sigaction(SIGINT, &act, NULL);

    while(1)
    {
		sigwait(&newmask, &lsigno);
		printf("i receive signo %d\n", lsigno);
        sleep(1);
    }
}

/*
 * SIGINT를 두개의 쓰레드로 서로다른 시간간격으로 
 * 전달한다. 
 */
void *s_signal(void *arg)
{
    int i = 1;
    while(1)
    {
        sleep(1);
        i++;
        if((i % 7) == 0)
        {
            printf("Send SIGINT %d\n", sigid[0]);
            pthread_kill(sigid[0], SIGINT);
        }
        if((i % 11) == 0)
        {
            printf("Send SIGINT %d\n", sigid[1]);
            pthread_kill(sigid[1], SIGINT);
        }
    }
}

################################################################################################
sig_handler
	tid와 signo를 출력

thread1
	newmask	// mask 변수
	act	// mask,action 변수

	tid 출력

	newmask에 비우고 SIGINT 추가
	thread에 SIG_BLOCK으로 newmask 추가

	act에 SIGINT 추가, sig_handler 추가

	반복
		1초마다 i++ 출력

thread2
	newmask	// mask 변수
	act	// mask,action 변수

	newmask 비우고 SIGINT 추가
	act에 SIGINT 추가, sig_handler 추가

	반복
		newmask에 set되어있는 signal이 올때까지 대기.
		기다리고 있던 sinal을 받으면 signal을 출력

s_signal
	7초마다 tid[0]에 SIGINT
	11초마다 tid[1]에 SIGINT

################################################################################################
전체적인 동작은
1초마다 i++이 출력되다가
7초마다 sig_handler가(thread1)
11초마다 signal이 출력됨(thread2)

################################################################################################
잘 알고 계시겠지만, sigaction으로는 별도의 handler를 지정이 가능합니다만 sigwait는 해당 signal이 오면 바로 return을 칩니다.
SIGUSR1이 올 때가지 기다리게 하려고 이렇게 구성하신 것이라면 구성이 잘못되었다고 보여지네요..

SIGUSR1을 올때까지 기다리다가 SIGUSR1에 대한 핸들러를 동작하고싶으면?
핸들러에 SIGINT 등록하고
sigwait(SIGINT)
해서 이게 잘 되는지 확인해야됨.
https://kldp.org/node/135686

